// -------------------------------------------------------------------------------------------------
// AZTEC library imports
const {	constants, proofs }      = require("@aztec/dev-utils");
const { secp256k1, note, proof } = require("aztec.js");



// -------------------------------------------------------------------------------------------------
// Instantiate contracts: CryptoEngine, proof systems, zkAsset[...]
async function instantiate(pantheon, txOptions) {
	var instances = {};

	// get contracts schemas
	const ACE                 = await pantheon.readContract("ACE.json");
	const ZKASSET_MINTABLE    = await pantheon.readContract("ZkAssetMintable.json");
	const JOINSPLIT           = await pantheon.readContract("JoinSplit.json");
	const ADJUST_SUPPLY       = await pantheon.readContract("AdjustSupply.json");

	// deploy crypto engine contract
	instances.ace             = await ACE.new(txOptions);
	instances.joinSplit       = await JOINSPLIT.new(txOptions);
	instances.adjustSupply    = await ADJUST_SUPPLY.new(txOptions);
	instances.zkAssetMintable = await ZKASSET_MINTABLE.new(
		instances.ace.address, 
		"0x0000000000000000000000000000000000000000", 	// ERC20 linked address (none)
		1, 												// scaling factor for ERC20 tokens
		true, 											// canMint
		false,  										// canConvert
		txOptions
	); 


	// set CRS and proof systems addresses
	await instances.ace.setCommonReferenceString(constants.CRS, txOptions);
	await instances.ace.setProof(proofs.JOIN_SPLIT_PROOF, instances.joinSplit.address, txOptions);
	await instances.ace.setProof(proofs.MINT_PROOF, instances.adjustSupply.address, txOptions);
	
	console.log("deployed ace at:             " + instances.ace.address);
	console.log("deployed joinSplit at:       " + instances.joinSplit.address);
	console.log("deployed adjustSupply at:    " + instances.adjustSupply.address);
	console.log("deployed zkAssetMintable at: " + instances.zkAssetMintable.address);

	return instances;
};


// -------------------------------------------------------------------------------------------------
// Mint initial supply for a zkAssetMintable
async function mintConfidentialAsset(notes, zkAssetMintable, txOptions) {
	// sum the value of notes to compute the total supply to mint
 	var totalMintedValue = 0;
	for (i = 0; i < notes.length; i++) { 
  		totalMintedValue += notes[i].k.toNumber();
	}

	// note representing new total supply
	const newTotalMinted = note.create(secp256k1.generateAccount().publicKey, totalMintedValue);
	const oldTotalMinted = note.createZeroValueNote(); // old total minted
	const adjustedNotes  = notes.map(x => x);

	// construct MINT PROOF
    var { proofData } = proof.mint.encodeMintTransaction({
        newTotalMinted, // new total minted
        oldTotalMinted, // old total minted
        adjustedNotes, 	// new notes distribution
        senderAddress: zkAssetMintable.address
    });

    // sending the transaction on the blockchain
	try {
		let receipt = await zkAssetMintable.confidentialMint(proofs.MINT_PROOF, proofData, txOptions)
		console.log("confidentialMint success. events:");
		prettyPrintEvents(receipt.logs);
	} catch (error) {
		console.log("confidentialMint failed: " + error);
		process.exit(-1);
	}
}

// -------------------------------------------------------------------------------------------------
// Confidential transfer. Destroy inputNotes, creates outputNotes through a joinSplit transaction
async function confidentialTransfer(inputNotes, inputNoteOwners, outputNotes, zkAssetMintable, joinSplit, txOptions) {
	// compute kPublic
	var kPublic = 0;
	for (i = 0; i < outputNotes.length; i++) { 
  		kPublic += outputNotes[i].k.toNumber();
	}
	for (i = 0; i < inputNotes.length; i++) { 
  		kPublic -= inputNotes[i].k.toNumber();
	}

	// construct the joinsplit proof
	var {
		proofData
	} = proof.joinSplit.encodeJoinSplitTransaction({
		inputNotes: inputNotes,
		outputNotes: outputNotes,
		senderAddress: txOptions.from,
		inputNoteOwners: inputNoteOwners,
		publicOwner: txOptions.from,
		kPublic: kPublic,
		validatorAddress: joinSplit.address
	});

	// send the transaction to the blockchain
	try {
		let receipt = await zkAssetMintable.confidentialTransfer(proofData, txOptions)
		console.log("confidentialTransfer success. events:");
		prettyPrintEvents(receipt.logs);
		
	} catch (error) {
		console.log("confidentialTransfer failed: " + error);
		process.exit(-1);
	}
};

// utility function to display Create and Destroy note event generated by ZkAsset.sol
function prettyPrintEvents(logs) {
	for (i = 0; i < logs.length; i++) {
		var e = logs[i];
		var toPrint = {event: e.event};
		if (e.event === "CreateNote" || e.event === "DestroyNote") {
			toPrint.owner = e.args.owner;
			toPrint.hash = e.args.noteHash;
			console.log(JSON.stringify(toPrint, null, 2));	
		} 
	}
}

module.exports = {
	instantiate,
	mintConfidentialAsset,
	confidentialTransfer,
	secp256k1,
	note
};